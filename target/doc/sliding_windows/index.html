<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `sliding_windows` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, sliding_windows">

    <title>sliding_windows - Rust</title>

    <link rel="stylesheet" type="text/css" href="../normalize.css">
    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc mod">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'>Crate sliding_windows</p><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'sliding_windows', ty: 'mod', relpath: '../'};</script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content">
<h1 class='fqn'><span class='in-band'>Crate <a class="mod" href=''>sliding_windows</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a class='srclink' href='../src/sliding_windows/lib.rs.html#1-104' title='goto source code'>[src]</a></span></h1>
<div class='docblock'><p>This crate provides an iterator adaptor that yields sliding windows into the elements of the wrapped Iterator.</p>

<p>Note that this adaptor does <strong>NEVER</strong> clone any element for huge speed gains.</p>

<p>As a consequence it violates the Iterator protocol slightly. It is not possible to have two Windows into the data
available at the same time. This is checked during runtime. If this check fails, the Adaptor panicks in <code>next()</code>.
More information can be found in the section <a href="#panics">Panics</a>.</p>

<p>There are some options regarding the constructor for Storage, which allow reuse of an allocation.
Consult the <a href="struct.Storage.html">docs for Storage</a> for details.</p>

<p>Iterator element type is <code>Window&lt;&#39;a, Self::Item&gt;</code>.</p>

<p>Note: <code>Window&lt;&#39;a, Self::Item&gt;</code> implements <code>iter()</code> and <code>iter_mut()</code>, which return Iterators over the elements of the <code>Window</code>.</p>

<p>This iterator is <em>fused</em>.</p>

<h1 id='example' class='section-header'><a href='#example'>Example:</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">sliding_windows</span>::<span class="ident">IterExt</span>;
<span class="kw">use</span> <span class="ident">sliding_windows</span>::<span class="ident">Storage</span>;

<span class="kw">let</span> <span class="ident">iter</span> <span class="op">=</span> <span class="number">0</span>..<span class="number">5</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">storage</span>: <span class="ident">Storage</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Storage</span>::<span class="ident">new</span>(<span class="number">3</span>);
<span class="kw">let</span> <span class="ident">windowed_iter</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">sliding_windows</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">storage</span>);
<span class="kw">let</span> <span class="ident">output</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="ident">windowed_iter</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>).<span class="ident">collect</span>()).<span class="ident">collect</span>();
<span class="kw">let</span> <span class="ident">expected</span>: <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span>[<span class="ident">u32</span>]] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span>[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="kw-2">&amp;</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="kw-2">&amp;</span>[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">output</span>, <span class="ident">expected</span>);</pre>

<p>It&#39;s also possible to reuse an allocation for <code>Storage</code> via the <code>Into</code> trait.</p>

<h1 id='example-1' class='section-header'><a href='#example-1'>Example:</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">sliding_windows</span>::<span class="ident">IterExt</span>;
<span class="kw">use</span> <span class="ident">sliding_windows</span>::<span class="ident">Storage</span>;

<span class="kw">let</span> <span class="ident">previous_alloca</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0u32</span>; <span class="number">3</span>]; <span class="comment">// length doesn&#39;t have to be equal to window_size</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">storage</span>: <span class="ident">Storage</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Storage</span>::<span class="ident">from_vec</span>(<span class="ident">previous_alloca</span>, <span class="number">3</span>);
<span class="kw">let</span> <span class="ident">expected</span>: <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span>[<span class="ident">u32</span>]] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span>[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="kw-2">&amp;</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="kw-2">&amp;</span>[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]];

<span class="comment">// extra scope so that windowed_iter doesn&#39;t outlive storage.into() call</span>
{
    <span class="kw">let</span> <span class="ident">windowed_iter</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">5</span>).<span class="ident">sliding_windows</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">storage</span>);
    <span class="kw">let</span> <span class="ident">output</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="ident">windowed_iter</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>).<span class="ident">collect</span>()).<span class="ident">collect</span>();
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">output</span>, <span class="ident">expected</span>);
}

<span class="kw">let</span> <span class="ident">reusing_alloca</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">storage</span>.<span class="ident">into</span>();
<span class="comment">// keep using allocation of storage</span>
</pre>

<h3 id='panics' class='section-header'><a href='#panics'>Panics:</a></h3>
<p>As this iterator reuses the allocation for the yielded <code>Window</code>, no two instances of <code>Window</code>
belonging to the same iterator may exist simultaneously. As noted above this is checked at runtime.</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">sliding_windows</span>::<span class="ident">IterExt</span>;
<span class="kw">use</span> <span class="ident">sliding_windows</span>::<span class="ident">Storage</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">storage</span>: <span class="ident">Storage</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Storage</span>::<span class="ident">new</span>(<span class="number">3</span>);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">windowed_iter</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">5</span>).<span class="ident">sliding_windows</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">storage</span>);

<span class="comment">// extra scope so that a doesn&#39;t live until the for loop</span>
{
    <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">windowed_iter</span>.<span class="ident">next</span>();
    <span class="comment">//let b = windowed_iter.next(); =&gt; this would PANIC</span>
}

<span class="comment">// looping for example is fine though</span>
<span class="kw">for</span> _ <span class="kw">in</span> <span class="ident">windowed_iter</span> {
    <span class="comment">// blah</span>
}</pre>

<h1 id='mutable-window' class='section-header'><a href='#mutable-window'>Mutable Window:</a></h1>
<p>There is an implementation of an Iterator over <code>&amp;&#39;a mut T</code> for <code>Window&lt;&#39;a, T&gt;</code>. It can be obtained
by calling <code>iter_mut()</code>. For more information see <a href="struct.Window.html"><code>Window&lt;&#39;a, T&gt;</code></a>.</p>

<p>However be aware that changes made to the items in the Window are persistent through calls to <code>next()</code>.</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Adaptor.html"
                                  title='struct sliding_windows::Adaptor'>Adaptor</a></td>
                           <td class='docblock-short'>
                                <p>See <a href="index.html">sliding_windows</a> for more information.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Storage.html"
                                  title='struct sliding_windows::Storage'>Storage</a></td>
                           <td class='docblock-short'>
                                <p>This holds the backing allocation for the <code>Window</code> of an <code>Adaptor</code>.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Window.html"
                                  title='struct sliding_windows::Window'>Window</a></td>
                           <td class='docblock-short'>
                                <p>This is the <code>Item</code> type of the <code>Adaptor</code> iterator.</p>
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.WindowIter.html"
                                  title='struct sliding_windows::WindowIter'>WindowIter</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.WindowIterMut.html"
                                  title='struct sliding_windows::WindowIterMut'>WindowIterMut</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.IterExt.html"
                                  title='trait sliding_windows::IterExt'>IterExt</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr></table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "sliding_windows";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    <script defer src="../search-index.js"></script>
</body>
</html>